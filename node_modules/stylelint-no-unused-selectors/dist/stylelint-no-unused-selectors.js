"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const unwrap_1 = require("option-t/lib/Undefinable/unwrap");
const andThen_1 = require("option-t/lib/Undefinable/andThen");
const array_prototype_flatmap_1 = __importDefault(require("array.prototype.flatmap"));
const stylelint_1 = __importDefault(require("stylelint"));
// @ts-ignore
const postcss_resolve_nested_selector_1 = __importDefault(require("postcss-resolve-nested-selector"));
const postcss_selector_parser_1 = __importDefault(require("postcss-selector-parser"));
const options_1 = require("./options");
const plugin_1 = require("./plugin");
const document_resolver_1 = require("./utils/document-resolver");
const remove_unassertive_selector_1 = require("./utils/remove-unassertive-selector");
exports.ruleName = 'plugin/no-unused-selectors';
exports.messages = stylelint_1.default.utils.ruleMessages(exports.ruleName, {
    rejected: (selector, documentName) => `${selector} is defined but doesn't match any elements in ${documentName}.`,
});
const selectorProcessor = postcss_selector_parser_1.default();
function getCSSSource(root) {
    return andThen_1.andThenForUndefinable(root.source, (s) => s.input.file);
}
function rule(options) {
    return async (root, result) => {
        if (options === false) {
            return;
        }
        const cssSrc = getCSSSource(root);
        if (!cssSrc) {
            return;
        }
        const opts = options_1.normaliseOptions(result, exports.ruleName, typeof options === 'object' ? options : {});
        if (!opts) {
            return;
        }
        const documentPaths = document_resolver_1.resolveDocuments(cssSrc, opts.resolve.documents);
        const resolution = await document_resolver_1.resolveDocument(documentPaths);
        if (!resolution) {
            return;
        }
        const { path: documentPath, document } = resolution;
        const pluginSet = await plugin_1.getPlugin(documentPath, opts.plugins);
        if (!pluginSet) {
            return;
        }
        const { plugin, options: pluginOptions } = pluginSet;
        await plugin.parse(document, pluginOptions);
        root.walkRules(async (rule) => {
            if (!rule.selectors) {
                return;
            }
            const resolvedSelectors = array_prototype_flatmap_1.default(rule.selectors, (selectors) => postcss_resolve_nested_selector_1.default(selectors, rule));
            async function processSelector(selector) {
                const selectorAst = await selectorProcessor.ast(selector);
                const filteredAst = remove_unassertive_selector_1.removeUnassertiveSelector(selectorAst);
                const matched = await unwrap_1.unwrapUndefinable(plugin).match(filteredAst, pluginOptions);
                if (!matched) {
                    stylelint_1.default.utils.report({
                        result,
                        ruleName: exports.ruleName,
                        node: rule,
                        message: exports.messages.rejected(selector, path_1.default.basename(documentPath)),
                    });
                }
            }
            await Promise.all(resolvedSelectors.map(processSelector));
        });
    };
}
exports.default = stylelint_1.default.createPlugin(exports.ruleName, rule);
