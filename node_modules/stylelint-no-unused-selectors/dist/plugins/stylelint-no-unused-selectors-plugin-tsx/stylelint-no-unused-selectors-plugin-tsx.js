"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const unwrap_1 = require("option-t/lib/Undefinable/unwrap");
const andThen_1 = require("option-t/lib/Undefinable/andThen");
const is_simple_selector_1 = require("../../utils/is-simple-selector");
function extractAttributeValue(node) {
    if (!node.initializer ||
        node.initializer.kind !== typescript_1.default.SyntaxKind.StringLiteral) {
        return;
    }
    return node.initializer.text;
}
function extractTextFromIdentifier(node) {
    return node.text || node.escapedText;
}
function extractSpecifiersFromImport(node, predicate) {
    if (!predicate(node)) {
        return [];
    }
    const clauseNode = node.importClause;
    if (!clauseNode) {
        return [];
    }
    if (clauseNode.name !== undefined) {
        return [extractTextFromIdentifier(clauseNode.name)];
    }
    if (!clauseNode.namedBindings) {
        return [];
    }
    if (typescript_1.default.isNamedImports(clauseNode.namedBindings)) {
        return clauseNode.namedBindings.elements.map((specifier) => extractTextFromIdentifier(specifier.name));
    }
    if (typescript_1.default.isNamespaceImport(clauseNode.namedBindings)) {
        return [extractTextFromIdentifier(clauseNode.namedBindings.name)];
    }
    return [];
}
function isRequireCall(node) {
    if (!node.initializer || !typescript_1.default.isCallExpression(node.initializer)) {
        return false;
    }
    const callNode = node.initializer;
    if (!typescript_1.default.isIdentifier(callNode.expression)) {
        return false;
    }
    const funcName = extractTextFromIdentifier(callNode.expression);
    return funcName === 'require';
}
function extractSpecifierFromRequire(node, predicate) {
    if (!predicate(node)) {
        return undefined;
    }
    const specifier = extractTextFromIdentifier(node.name);
    return specifier;
}
function extractArgumentsFromClassnamesCall(node) {
    const classes = [];
    node.arguments.forEach((arg) => {
        switch (arg.kind) {
            case typescript_1.default.SyntaxKind.StringLiteral: {
                const className = arg.text;
                if (className) {
                    classes.push(className);
                }
                break;
            }
            case typescript_1.default.SyntaxKind.ObjectLiteralExpression: {
                const stringProps = arg.properties.filter((prop) => typescript_1.default.isPropertyAssignment(prop) && typescript_1.default.isStringLiteral(prop.name));
                const keys = stringProps
                    .map((prop) => prop.name.text)
                    .filter((key) => !!key);
                classes.push(...keys);
                break;
            }
        }
    });
    return classes;
}
function extractClassesAndIds(sourceFile) {
    const cssModuleSpecifiers = [];
    const classNamesSpecifiers = [];
    const classes = [];
    const ids = [];
    function handleClassNameAndIdAttributes(node) {
        switch (node.kind) {
            case typescript_1.default.SyntaxKind.JsxAttribute:
                {
                    const attrNode = node;
                    if (extractTextFromIdentifier(attrNode.name) === 'className') {
                        const classNames = extractAttributeValue(attrNode);
                        if (classNames) {
                            const normalisedClassNames = classNames
                                .split(' ')
                                .filter((c) => !!c)
                                .map((c) => `.${c}`);
                            classes.push(...normalisedClassNames);
                        }
                    }
                    if (attrNode.name.text === 'id') {
                        const idNames = extractAttributeValue(attrNode);
                        if (idNames) {
                            const normalisedIdNames = idNames
                                .split(' ')
                                .filter((i) => !!i)
                                .map((i) => `#${i}`);
                            ids.push(...normalisedIdNames);
                        }
                    }
                }
                break;
        }
    }
    function handleCSSModules(node) {
        switch (node.kind) {
            case typescript_1.default.SyntaxKind.ImportDeclaration: {
                const declNode = node;
                const specifiers = extractSpecifiersFromImport(declNode, (node) => {
                    return node.moduleSpecifier.text.endsWith('.css');
                });
                cssModuleSpecifiers.push(...specifiers);
                break;
            }
            case typescript_1.default.SyntaxKind.VariableDeclaration: {
                const declNode = node;
                if (!isRequireCall(declNode)) {
                    break;
                }
                const specifier = extractSpecifierFromRequire(declNode, (node) => {
                    const callNode = unwrap_1.unwrapUndefinable(node.initializer);
                    const arg = callNode.arguments[0];
                    return typescript_1.default.isStringLiteral(arg) && arg.text.endsWith('.css');
                });
                andThen_1.andThenForUndefinable(specifier, (s) => void cssModuleSpecifiers.push(s));
                break;
            }
            case typescript_1.default.SyntaxKind.PropertyAccessExpression: {
                const exprNode = node;
                const objName = extractTextFromIdentifier(exprNode.expression);
                if (!cssModuleSpecifiers.includes(objName)) {
                    break;
                }
                const className = extractTextFromIdentifier(exprNode.name);
                classes.push(`.${className}`);
                break;
            }
            case typescript_1.default.SyntaxKind.ElementAccessExpression: {
                const exprNode = node;
                const objName = extractTextFromIdentifier(exprNode.expression);
                if (!cssModuleSpecifiers.includes(objName)) {
                    break;
                }
                const className = exprNode.argumentExpression
                    .text;
                classes.push(`.${className}`);
                break;
            }
        }
    }
    function handleClassNames(node) {
        switch (node.kind) {
            case typescript_1.default.SyntaxKind.ImportDeclaration: {
                const declNode = node;
                const specifiers = extractSpecifiersFromImport(declNode, (node) => {
                    return (node.moduleSpecifier.text === 'classnames');
                });
                classNamesSpecifiers.push(...specifiers);
                break;
            }
            case typescript_1.default.SyntaxKind.VariableDeclaration: {
                const declNode = node;
                if (!isRequireCall(declNode)) {
                    break;
                }
                const specifier = extractSpecifierFromRequire(declNode, (node) => {
                    const callNode = unwrap_1.unwrapUndefinable(node.initializer);
                    const arg = callNode.arguments[0];
                    return typescript_1.default.isStringLiteral(arg) && arg.text === 'classnames';
                });
                andThen_1.andThenForUndefinable(specifier, (s) => void classNamesSpecifiers.push(s));
                break;
            }
            case typescript_1.default.SyntaxKind.CallExpression: {
                const callNode = node;
                if (!typescript_1.default.isIdentifier(callNode.expression)) {
                    break;
                }
                const funcName = extractTextFromIdentifier(callNode.expression);
                if (!classNamesSpecifiers.includes(funcName)) {
                    break;
                }
                const args = extractArgumentsFromClassnamesCall(callNode);
                const classNames = args.map((className) => `.${className}`);
                classes.push(...classNames);
                break;
            }
        }
    }
    function visitor(node) {
        handleClassNameAndIdAttributes(node);
        handleCSSModules(node);
        handleClassNames(node);
        typescript_1.default.forEachChild(node, visitor);
    }
    visitor(sourceFile);
    return { classes, ids };
}
let cache = {
    ast: undefined,
    classes: [],
    ids: [],
};
function parse(tsx) {
    const ast = typescript_1.default.createSourceFile('foo.tsx', tsx, typescript_1.default.ScriptTarget.Latest);
    const { classes, ids } = extractClassesAndIds(ast);
    cache.ast = ast;
    cache.classes = classes;
    cache.ids = ids;
}
exports.parse = parse;
function match(selectorAst) {
    if (cache.ast === undefined) {
        throw new Error('Call parse() before match().');
    }
    // Skip if the given selector is not composed of only one class or id.
    if (!is_simple_selector_1.isSimpleSelector(selectorAst)) {
        return true;
    }
    const selector = selectorAst.toString();
    if (cache.classes.includes(selector)) {
        return true;
    }
    if (cache.ids.includes(selector)) {
        return true;
    }
    return false;
}
exports.match = match;
