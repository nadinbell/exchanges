"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BabelParser = __importStar(require("@babel/parser"));
const traverse_1 = __importDefault(require("@babel/traverse"));
const andThen_1 = require("option-t/lib/Undefinable/andThen");
const is_simple_selector_1 = require("../../utils/is-simple-selector");
function extractAttributeValue(node) {
    const valueNode = node.value;
    if (!valueNode || valueNode.type !== 'StringLiteral') {
        return;
    }
    return valueNode.value;
}
function extractSpecifiersFromImport(node, predicate) {
    if (!predicate(node)) {
        return [];
    }
    return node.specifiers.map((specifier) => specifier.local.name);
}
function isRequireCall(node) {
    if (!node.init || node.init.type !== 'CallExpression') {
        return false;
    }
    const funcName = node.init.callee.name;
    return funcName === 'require';
}
function extractSpecifierFromRequire(node, predicate) {
    if (!predicate(node)) {
        return undefined;
    }
    return node.id.name;
}
function extractArgumentsFromClassnamesCall(node) {
    const classes = [];
    node.arguments.forEach((arg) => {
        switch (arg.type) {
            case 'StringLiteral': {
                const className = arg.value;
                if (className) {
                    classes.push(className);
                }
                break;
            }
            case 'ObjectExpression': {
                const keys = arg.properties
                    .filter((prop) => prop.type === 'ObjectProperty')
                    .map((prop) => prop.key.value)
                    .filter((key) => !!key);
                classes.push(...keys);
                break;
            }
        }
    });
    return classes;
}
function extractClassesAndIds(ast) {
    const cssModuleSpecifiers = [];
    const classNamesSpecifiers = [];
    const classes = [];
    const ids = [];
    function handleClassNameAndIdAttributes(node) {
        switch (node.type) {
            case 'JSXAttribute': {
                if (node.name.name === 'className') {
                    const classNames = extractAttributeValue(node);
                    if (classNames) {
                        const normalisedClassNames = classNames
                            .split(' ')
                            .filter((c) => !!c)
                            .map((c) => `.${c}`);
                        classes.push(...normalisedClassNames);
                    }
                }
                if (node.name.name === 'id') {
                    const idNames = extractAttributeValue(node);
                    if (idNames) {
                        const normalisedIdNames = idNames
                            .split(' ')
                            .filter((i) => !!i)
                            .map((i) => `#${i}`);
                        ids.push(...normalisedIdNames);
                    }
                }
                break;
            }
        }
    }
    function handleCSSModules(node) {
        switch (node.type) {
            case 'ImportDeclaration': {
                const specifiers = extractSpecifiersFromImport(node, (node) => {
                    return node.source.value.endsWith('.css');
                });
                cssModuleSpecifiers.push(...specifiers);
                break;
            }
            case 'VariableDeclarator': {
                if (!isRequireCall(node)) {
                    return;
                }
                const specifier = extractSpecifierFromRequire(node, (n) => {
                    const source = n.init
                        .arguments[0].value;
                    return !!source && source.endsWith('.css');
                });
                andThen_1.andThenForUndefinable(specifier, (s) => void cssModuleSpecifiers.push(s));
                break;
            }
            case 'MemberExpression': {
                const objName = node.object.name;
                if (!cssModuleSpecifiers.includes(objName)) {
                    break;
                }
                const className = node.property.value || node.property.name;
                classes.push(`.${className}`);
                break;
            }
        }
    }
    function handleClassNames(node) {
        switch (node.type) {
            case 'ImportDeclaration': {
                const declNode = node;
                const specifiers = extractSpecifiersFromImport(declNode, (node) => {
                    return node.source.value === 'classnames';
                });
                classNamesSpecifiers.push(...specifiers);
                break;
            }
            case 'VariableDeclarator': {
                if (!isRequireCall(node)) {
                    return;
                }
                const specifier = extractSpecifierFromRequire(node, (n) => {
                    const source = n.init
                        .arguments[0].value;
                    return !!source && source === 'classnames';
                });
                andThen_1.andThenForUndefinable(specifier, (s) => void classNamesSpecifiers.push(s));
                break;
            }
            case 'CallExpression': {
                const funcName = node.callee.name;
                if (!classNamesSpecifiers.includes(funcName)) {
                    break;
                }
                const args = extractArgumentsFromClassnamesCall(node);
                const classNames = args.map((className) => `.${className}`);
                classes.push(...classNames);
            }
        }
    }
    traverse_1.default(ast, {
        enter(path) {
            const { node } = path;
            handleClassNameAndIdAttributes(node);
            handleCSSModules(node);
            handleClassNames(node);
        },
    });
    return { classes, ids };
}
let cache = {
    ast: undefined,
    classes: [],
    ids: [],
};
function parse(jsx, parserOptions) {
    const ast = BabelParser.parse(jsx, parserOptions);
    const { classes, ids } = extractClassesAndIds(ast);
    cache.ast = ast;
    cache.classes = classes;
    cache.ids = ids;
}
exports.parse = parse;
function match(selectorAst) {
    if (cache.ast === undefined) {
        throw new Error('Call parse() before match().');
    }
    // Skip if the given selector is not composed of only one class or id.
    if (!is_simple_selector_1.isSimpleSelector(selectorAst)) {
        return true;
    }
    const selector = selectorAst.toString();
    if (cache.classes.includes(selector)) {
        return true;
    }
    if (cache.ids.includes(selector)) {
        return true;
    }
    return false;
}
exports.match = match;
